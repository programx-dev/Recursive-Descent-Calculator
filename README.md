# Лабораторная работа 1

**Автор**: Смирнов Никита  
**Группа**: М8О-101-БВ-25  
**Вариант**: M1  (Рекурсивный спуск) 

---

## Назначение

Калькулятор реализован на Python3.12 и предназначен для вычисления арифметических выражений, заданных строкой.  
Поддерживаются:

- сложение (`+`)  
- вычитание (`-`)  
- умножение (`*`)  
- деление (`/`)  
- целочисленное деление (`//`)  
- остаток от деления (`%`)  
- возведение в степень (`**`)  
- круглые скобки для группировки выражений  

---

## Использование main.py (точка входа)

Находясь в корне проекта (там где лежат `/src` и `/tests`), введите сделующие команды в терминал:

```bash
python3 -m src.main

# или, если не сработал первый вариант

python -m src.main
```

---

## Запуск tests.py (тесты)

Находясь в корне проекта (там где лежат `/src` и `/tests`), введите сделующие команды в терминал:

```bash
python3 -m tests.tests

# или, если не сработал первый вариант

python -m tests.tests
```

---

## Принятые решения и допущения

1. Для удобства метод `__new__` переопределён так, что можно сразу писать `Calc("2+2")`, а вызывать метод `Calc.eval("2+2")`. Класс `Calc` статический — создавать экземпляры не требуется.

2. Для разбиения строки на токены используются регулярные выражения. Поддерживаются унарные знаки (`+`, `-`) как в начале строки, так и после операторов или скобок.

3. Поддерживаются как целые числа (42), так и вещественные (3.14). Все числа на этапе токенизации приводятся к `float`.

4. Все ошибки перехватываются и выбрасываются как `CalcError` с понятным сообщением.

5. `//` и `%` допустимы только для целых чисел (проверка через `is_integer()`).

6. Возведение в степень реализовано как правая ассоциативность: `2**3**2 = 2**(3**2) = 512`. Неопределенность `0**0` обрабатывается отдельно.

7. Все константы для регулярных выражений вынесены в отдельный класс для удобной организации

8. Выражения не содержашие числа, например такие как ` `, `((()))`, `+-`, являются некорректными

---

## Алгоритм парсинга

Парсинг реализован через рекурсивный спуск.
Грамматика выражения:

```
expr    := add
add     := mull (('+'|'-') mull)*
mull    := pow  (('*'|'/'|'//'|'%') pow)*
pow     := primary ('**' pow)?
primary := NUM | '(' add ')'
```

---

## Шаги работы калькулятора:

1. Проверка выражения `validate_expr`  
Сначала проверяется, что в строке содержатся только допустимые символы (цифры, операторы, скобки, пробелы).

2. Лексический анализ `parse`  
Регулярными выражениями строка разбивается на последовательность токенов: числа, операторы, скобки.

3. Токенизация `tokenize`  
Каждому токену присваивается тип:
    * `("NUM", value)` для числа
    * `(оператор, None)` для операторов и скобок
    * `("EOF", None)` в конец для удобства

4. Проверка скобок `check_brackets` 
Используется стек для проверки корректности скобочной структуры.

5. Синтаксический анализ `parse_add` → `parse_mull` → `parse_pow` → `parse_primary`   
    * `parse_add` обрабатывает `+` и `-`.
    * `parse_mull` обрабатывает `*`, `/`, `//`, `%`.
    * `parse_pow` обрабатывает `**` (право-ассоциативно).
    * `parse_primary` возвращает число или рекурсивно вызывает `parse_add` для выражения в скобках.

6. Вычисление  
По мере синтаксического анализа сразу же выполняются арифметические операции. В итоге возвращается значение выражения в виде `float`.